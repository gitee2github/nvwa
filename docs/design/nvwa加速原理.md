## 原理简介

在内核热替换的过程中，需要解决的核心问题有两个：

1. 进程运行现场的保存和恢复
2. 系统重启过程中，内核的快速替换

为了解决第一个问题，nvwa使用了criu(Checkpoint/Restore In Userspace)。criu是一个在用户态对进程进行状态保存和恢复的工具，关于criu的更多信息，可以参考[此处](https://criu.org)。

为解决第二个问题，nvwa使用了kexec(directly boot into a new kernel)。kexec是系统调用，借助kexec，可以从现在内核直接进入新内核，从而极大的加速内核切换的过程，关于kexec的更多信息，可以参考[此处](https://linux.die.net/man/8/kexec)。

当然，criu的使用还存在诸多限制。比如对tty设备的支持，对file-lock的支持等等。kexec的速度也未能达到预期的要求，无法在业务容忍范围内完成重启。对于这些问题，nvwa对criu和kexec进行了一些改造。改造主要可以分为两类：一类是减少整个过程的耗时；一类是丰富应用场景，减少使用限制。

### 加速特性

1. cpu park(加速从核状态切换)

在kexec原有的重启过程中，当内核进行关机操作时，除了主核外，从核会停止运行。等到内核开始运行后，主核发送中断，唤醒其他从核，这一过程涉及从核的状态变化，是十分耗费时间的。

所谓cpu park，是指在这一过程中，让从核直接轮询在某一物理地址上，等主核进入某一节点时，直接向某处约定好的物理地址写入相应的值，使从核直接进入正常状态。

2. quick kexec(加速kexec加载内核的过程)

通过预留kexec使用的内存，加速kexec切换内核。原kexec流程，先将kernel和initramfs等image加载到内核态vmalloc的物理不连续的内存中，在切换内核(relocate)时，通过汇编语句将内存中的images拷贝到内核启动使用的连续物理内存中，在arm64架构下，该动作是在关闭MMU的情况下执行，按字节拷贝，速度很慢，通常有30秒以上。通过提前预留内存的方式，在kexec load时即将images拷贝到连续物理地址中，切换内核时直接在预留的物理地址启动，减少了拷贝动作。

在x86架构下，quick kexec也有极好的性能提升。

3. pin memory(加速criu保存和恢复现场过程)

criu原生的流程中，应用状态备份流程中需要将应用内存dump到文件中，并通过读取文件内容来恢复应用内存状态，当应用内存很大时，该过程非常耗时。
pin memory机制将应用内存数据直接pin在内存中，保证应用备份恢复过程中内存数据不被改写，并在应用状态恢复过程中将pin住的物理页重映射至应用进程，实现了应用内存数据的快速备份恢复。

### 丰富应用场景

1. criu恢复现场过程中，pid被占用问题

对于一些进程号比较小的进程，在恢复过程中，很容易出现pid已经被占用的问题。针对这一问题，nvwa使用了一种简单的策略，每次启动后，会在上一次系统的/proc/sys/kernel/ns_last_pid值基础上增大，从而减少了与之前保存进程的进程号之间的竞争。当然，这种策略无法根本上解决问题，只能极大减少问题出现的概率。

2. criu在恢复现场过程中，文件锁的持有者产生变化

criu对文件锁的支持仍然不够完善，criu记录的file locks的信息，来自于/proc下的fd信息。这一信息的局限性在于，只有持有进程记录了锁的信息，等待者由于一直挂在flock系统调用过程中。在恢复file locks时，有可能出现，原有的等待者在原有的持有者之前获得了file lock，导致程序出现预期之外的行为。为了解决这一问题，nvwa从/proc/locks下读取锁的持有者和等待者信息，如果发现当前进程是持有者，会一直等待持有者上线，避免破坏锁的行为。当前这一策略还在实现中，下一个版本将会加入。
